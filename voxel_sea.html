<html>
	<head>
		<title>Voxel Sea!</title>
		<style>
		
		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}
		
		canvas { 
			width: 100%; 
			height: 100%;
		}
	
	</style>
		<script src="lib/three.min.js"></script>
		<script src="lib/stats.min.js"></script>
		<script src="lib/Coordinates.js"></script>
		<script src="lib/OrbitControls.js"></script>
	</head>
	<body>

		<script type="x-shader/x-vertex" id="vertexshader">

			uniform float amplitude;

			attribute float displacement;

			varying vec3 vNormal;
			//varying vec2 vUv;

			void main() {

				vNormal = normal;
				//vUv = ( 0.5 + amplitude ) * uv + vec2( amplitude );

        vec3 upVec = vec3(0,1,0);

				vec3 newPosition = position + amplitude * upVec * vec3( displacement );

				gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );
			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">

			varying vec3 vNormal;
			//varying vec2 vUv;

			uniform vec3 color;
			//uniform sampler2D colorTexture;

			void main() {

				vec3 light = vec3( 0.5, 0.2, 1.0 );
				light = normalize( light );

				float dProd = dot( vNormal, light ) * 0.5 + 0.5;
				//float dProd = dot( vNormal, vec3(1) ) * 0.5 + 0.5;

				//vec4 tcolor = texture2D( colorTexture, vUv );
				//vec4 gray = vec4( vec3( tcolor.r * 0.3 + tcolor.g * 0.59 + tcolor.b * 0.11 ), 1.0 );
				vec4 gray = vec4( 1 );

				gl_FragColor = gray * vec4( vec3( dProd ) * vec3( color ), 1.0 );

			}

		</script>

		
		<script>
		
		var scene, camera, renderer, controls, stats;
    var world;
    var mesh;

    let uniforms, displacement;
    let geometry;
		
		function Start() {
			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

			renderer = new THREE.WebGLRenderer( {antialias: true} );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setClearColor( 0xf0f0f0 );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.gammaInput = true;
			renderer.gammaOutput = true;
			renderer.shadowMap.enabled = true;
			document.body.appendChild( renderer.domElement );
			
			//camera.position.set(2,2,2);
      //var cpos = 20;
      var cpos = 15;
			//camera.position.set(10, 5, cpos);
			//camera.position.set(10,0,20);
			camera.position.set(22,3,17);
			//camera.lookAt( new THREE.Vector3(0,3,0)); // Useless if OrbitControl
			                                            // Use control.target = new ...
			
      // LIGHTS
			var hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
			hemiLight.color.setHSL( 0.6, 1, 0.6 );
			hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
			hemiLight.position.set( 0, 500, 0 );
			scene.add( hemiLight );
      
			var dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
			dirLight.color.setHSL( 0.1, 1, 0.95 );
			dirLight.position.set( -1, 1.75, 1 );
			dirLight.position.multiplyScalar( 50 );
			scene.add( dirLight );
			dirLight.castShadow = true;
			dirLight.shadow.mapSize.width = 1024;
			dirLight.shadow.mapSize.height = 1024;

			// GROUND
			var groundGeo = new THREE.PlaneBufferGeometry( 10000, 10000 );
			var groundMat = new THREE.MeshPhongMaterial( { color: 0xffffff, specular: 0x050505 } );
			groundMat.color.setHSL( 0.095, 1, 0.75 );
			var ground = new THREE.Mesh( groundGeo, groundMat );
			//ground.position.y = -0.5;
			ground.rotation.x = -Math.PI/2;
			//scene.add( ground );
			ground.receiveShadow = true;
			
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			document.body.appendChild( stats.domElement );
			
			// uncomment if you need to draw coordinate axes when building the scene
			Coordinates.drawAllAxes();
			
			controls = new THREE.OrbitControls( camera );
			controls.addEventListener( 'change', Render );
      controls.target = new THREE.Vector3(0,0,5);

      // From here inspired by
      // https://threejsfundamentals.org/threejs/lessons/threejs-voxel-geometry.html

      // TEXTURE LOADING
      const loader = new THREE.TextureLoader();
      const texture = loader.load('textures/flourish-cc-by-nc-sa.png', Render);
      texture.magFilter = THREE.NearestFilter;
      texture.minFilter = THREE.NearestFilter;


      const cellSize = 64;
      //const cellSize = 5;

      const tileSize = 16;
      const tileTextureWidth = 256;
      const tileTextureHeight = 64;

      world = new VoxelWorld({
        cellSize,
        tileSize,
        tileTextureWidth,
        tileTextureHeight,
      });


      // SEA
      seaTextureNum = 13;
      seaDim = 18

      for (let x = 0; x < seaDim; ++x) {
        for (let z = 0; z < seaDim; ++z) {
          world.setVoxel(x, 0,z, seaTextureNum);
        }
      }

      // CREATE MESH FOR CELL
      const {positions, normals, uvs, indices} = world.generateGeometryDataForCell(0, 0, 0, full=true);
      geometry = new THREE.BufferGeometry();

      uniforms = {
        "amplitude": { value: 1.0 },
        "color": { value: new THREE.Color( 0x006994 ) },
        //"colorTexture": { value: new THREE.TextureLoader().load( "textures/water.jpg" ) }
        //"texture": { value: new THREE.TextureLoader().load('textures/flourish-cc-by-nc-sa.png', Render)} // TODO
      };

      const material = new THREE.ShaderMaterial( {
        //map: texture,
        side: THREE.DoubleSide,
        alphaTest: 0.1,
        transparent: true,
        //color: 'green',
        //wireframe: true,

        uniforms: uniforms,
        vertexShader: document.getElementById( 'vertexshader' ).textContent,
        fragmentShader: document.getElementById( 'fragmentshader' ).textContent
      } );


      // //const material = new THREE.MeshPhongMaterial({
      // const material = new THREE.MeshLambertMaterial({
      //   map: texture,
      //   side: THREE.DoubleSide,
      //   alphaTest: 0.1,
      //   transparent: true,
      //   //color: 'green',
      //   //wireframe: true,
      // });

      const positionNumComponents = 3;
      const normalNumComponents = 3;
      const uvNumComponents = 2;
      geometry.setAttribute(
          'position',
          new THREE.BufferAttribute(new Float32Array(positions), positionNumComponents));
      geometry.setAttribute(
          'normal',
          new THREE.BufferAttribute(new Float32Array(normals), normalNumComponents));
      geometry.setAttribute(
          'uv',
          new THREE.BufferAttribute(new Float32Array(uvs), uvNumComponents));
      geometry.setIndex(indices);


      displacement = new Float32Array( geometry.attributes.position.count );
      geometry.setAttribute( 'displacement', new THREE.BufferAttribute( displacement, 1 ) );

      mesh = new THREE.Mesh(geometry, material);

      // TODO fix shadows
			//mesh.castShadow = true;
			//mesh.receiveShadow = true;

      scene.add(mesh);
		}

    function randInt(min, max) {
      return Math.floor(Math.random() * (max - min) + min);
    }



    class VoxelWorld {

      constructor(options) {
        this.cellSize = options.cellSize;

        this.tileSize = options.tileSize;
        this.tileTextureWidth = options.tileTextureWidth;
        this.tileTextureHeight = options.tileTextureHeight;

        const {cellSize} = this; // why needed?

        this.cellSliceSize = cellSize * cellSize;
        this.cells = {};
      }

      computeCellId(x, y, z) {
        const {cellSize} = this;
        const cellX = Math.floor(x / cellSize);
        const cellY = Math.floor(y / cellSize);
        const cellZ = Math.floor(z / cellSize);
        return `${cellX},${cellY},${cellZ}`; // create string
      }

      computeVoxelOffset(x, y, z) {
        const {cellSize, cellSliceSize} = this;
        const voxelX = THREE.Math.euclideanModulo(x, cellSize) | 0;
        const voxelY = THREE.Math.euclideanModulo(y, cellSize) | 0;
        const voxelZ = THREE.Math.euclideanModulo(z, cellSize) | 0;
        return voxelY * cellSliceSize +
               voxelZ * cellSize +
               voxelX;
      }

      getCellForVoxel(x, y, z) {
        return this.cells[this.computeCellId(x, y, z)];
      }

      addCellForVoxel(x, y, z) {
        const cellId = this.computeCellId(x, y, z);
        let cell = this.cells[cellId];
        if (!cell) {
          const {cellSize} = this;
          cell = new Uint8Array(cellSize * cellSize * cellSize);
          this.cells[cellId] = cell;
        }
        return cell;
      }

      setVoxel(x, y, z, v) {
        let cell = this.getCellForVoxel(x, y, z);
        if (!cell) {
          cell = this.addCellForVoxel(x, y, z);
        }
        const voxelOffset = this.computeVoxelOffset(x, y, z);
        cell[voxelOffset] = v;
      }

      getVoxel(x, y, z) {
        const cell = this.getCellForVoxel(x, y, z);
        if (!cell) {
          return 0;
        }
        const voxelOffset = this.computeVoxelOffset(x, y, z);
        return cell[voxelOffset];
      }

      generateGeometryDataForCell(cellX, cellY, cellZ, full = false) {
         const {cellSize, tileSize, tileTextureWidth, tileTextureHeight} = this;
         const positions = [];
         const normals = [];
         const uvs = [];
         const indices = [];
         const startX = cellX * cellSize;
         const startY = cellY * cellSize;
         const startZ = cellZ * cellSize;

         for (let y = 0; y < cellSize; ++y) {
           const voxelY = startY + y;
           for (let z = 0; z < cellSize; ++z) {
             const voxelZ = startZ + z;
             for (let x = 0; x < cellSize; ++x) {
               const voxelX = startX + x;
               const voxel = this.getVoxel(voxelX, voxelY, voxelZ);
               if (voxel) {
                 // voxel 0 is sky (empty) so for UVs we start at 0
                 const uvVoxel = voxel - 1;
                 // There is a voxel here but do we need faces for it?
                 for (const {dir, corners, uvRow} of VoxelWorld.faces) {
                   const neighbor = this.getVoxel(
                       voxelX + dir[0],
                       voxelY + dir[1],
                       voxelZ + dir[2]);

                   if (!neighbor || full) {

                     // this voxel has no neighbor in this direction so we need a face.
                     const ndx = positions.length / 3;
                     for (const {pos, uv} of corners) {
                       positions.push(pos[0] + x, pos[1] + y, pos[2] + z);
                       normals.push(...dir);
                       uvs.push(
                             (uvVoxel +   uv[0]) * tileSize / tileTextureWidth,
                         1 - (uvRow + 1 - uv[1]) * tileSize / tileTextureHeight);
                     }
                     indices.push(
                       ndx, ndx + 1, ndx + 2,
                       ndx + 2, ndx + 1, ndx + 3,
                     );
                   }
                 }
               }
             }
           }
         }

         return {
           positions,
           normals,
           uvs,
           indices};
      }


    }


    VoxelWorld.faces = [
      { // left
        uvRow: 0,
        dir: [ -1,  0,  0, ],
        corners: [
          { pos: [ 0, 1, 0 ], uv: [ 0, 1 ], },
          { pos: [ 0, 0, 0 ], uv: [ 0, 0 ], },
          { pos: [ 0, 1, 1 ], uv: [ 1, 1 ], },
          { pos: [ 0, 0, 1 ], uv: [ 1, 0 ], },
        ],
      },
      { // right
        uvRow: 0,
        dir: [  1,  0,  0, ],
        corners: [
          { pos: [ 1, 1, 1 ], uv: [ 0, 1 ], },
          { pos: [ 1, 0, 1 ], uv: [ 0, 0 ], },
          { pos: [ 1, 1, 0 ], uv: [ 1, 1 ], },
          { pos: [ 1, 0, 0 ], uv: [ 1, 0 ], },
        ],
      },
      { // bottom
        uvRow: 1,
        dir: [  0, -1,  0, ],
        corners: [
          { pos: [ 1, 0, 1 ], uv: [ 1, 0 ], },
          { pos: [ 0, 0, 1 ], uv: [ 0, 0 ], },
          { pos: [ 1, 0, 0 ], uv: [ 1, 1 ], },
          { pos: [ 0, 0, 0 ], uv: [ 0, 1 ], },
        ],
      },
      { // top
        uvRow: 2,
        dir: [  0,  1,  0, ],
        corners: [
          { pos: [ 0, 1, 1 ], uv: [ 1, 1 ], },
          { pos: [ 1, 1, 1 ], uv: [ 0, 1 ], },
          { pos: [ 0, 1, 0 ], uv: [ 1, 0 ], },
          { pos: [ 1, 1, 0 ], uv: [ 0, 0 ], },
        ],
      },
      { // back
        uvRow: 0,
        dir: [  0,  0, -1, ],
        corners: [
          { pos: [ 1, 0, 0 ], uv: [ 0, 0 ], },
          { pos: [ 0, 0, 0 ], uv: [ 1, 0 ], },
          { pos: [ 1, 1, 0 ], uv: [ 0, 1 ], },
          { pos: [ 0, 1, 0 ], uv: [ 1, 1 ], },
        ],
      },
      { // front
        uvRow: 0,
        dir: [  0,  0,  1, ],
        corners: [
          { pos: [ 0, 0, 1 ], uv: [ 0, 0 ], },
          { pos: [ 1, 0, 1 ], uv: [ 1, 0 ], },
          { pos: [ 0, 1, 1 ], uv: [ 0, 1 ], },
          { pos: [ 1, 1, 1 ], uv: [ 1, 1 ], },
        ],
      },
    ];

		function Update() {
			requestAnimationFrame( Update );
			controls.update();  
			stats.update();
			Render();
		}
		
    function Render() {
      const time = Date.now() * 0.005;
      
      var group = 0;
      var groupNum = 4 * 6 * seaDim; // 4 vertici per faccia per 6 facce per righe del mare

      for ( let i = 1; i <= displacement.length; i ++ ) {
        displacement[ i ] = 0.3 * Math.sin( 0.5 * (group + time));

        if (i % groupNum == 0) {
          group++;
        }
      }
      mesh.geometry.attributes.displacement.needsUpdate = true;

      renderer.render(scene, camera);
    }
		
		Start();
		Update();
			
		</script>
	</body>
</html>
