<html>
	<head>
		<title>Experimenting with voxel</title>
		<style>
		
		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}
		
		canvas { 
			width: 100%; 
			height: 100%;
		}
	
	</style>
		<script src="lib/three.min.js"></script>
		<script src="lib/stats.min.js"></script>
		<script src="lib/Coordinates.js"></script>
		<script src="lib/OrbitControls.js"></script>
	</head>
	<body>
		
		<script>
		
		var scene, camera, renderer, controls, stats;
    var world;
		
		function Start() {
			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

			renderer = new THREE.WebGLRenderer( {antialias: true} );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setClearColor( 0xf0f0f0 );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.gammaInput = true;
			renderer.gammaOutput = true;
			renderer.shadowMap.enabled = true;
			document.body.appendChild( renderer.domElement );
			
			//camera.position.set(2,2,2);
      var cpos = 50;
      var cpos = 10;
			camera.position.set(cpos, cpos, cpos);
			camera.lookAt( new THREE.Vector3(0,0,0));
			
			//var geometry = new THREE.BoxGeometry(1,1,1);
			//const loader = new THREE.TextureLoader();
			//loader.load('textures/11635.jpg', (texture => {
			//	var material = new THREE.MeshPhongMaterial( { map: texture } );
			//	var cube = new THREE.Mesh( geometry, material );
			//	cube.castShadow = true;
			//	cube.receiveShadow = true;
			//
			//	scene.add( cube );
			//}));
			//loader.load('textures/11635.jpg', (texture => {
			//	var material = new THREE.MeshPhongMaterial( { map: texture } );
			//	var cube = new THREE.Mesh( geometry, material );
			//	cube.castShadow = true;
			//	//cube.position.x = .5;
			//	cube.position.y = 1;
			//	cube.position.z = 1;
			//	cube.receiveShadow = true;
			//
			//	scene.add( cube );
			//}));
			
      // LIGHTS
			var hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
			hemiLight.color.setHSL( 0.6, 1, 0.6 );
			hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
			hemiLight.position.set( 0, 500, 0 );
			scene.add( hemiLight );
      
			var dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
			dirLight.color.setHSL( 0.1, 1, 0.95 );
			dirLight.position.set( -1, 1.75, 1 );
			dirLight.position.multiplyScalar( 50 );
			scene.add( dirLight );
			dirLight.castShadow = true;
			dirLight.shadow.mapSize.width = 1024;
			dirLight.shadow.mapSize.height = 1024;

			// GROUND
			var groundGeo = new THREE.PlaneBufferGeometry( 10000, 10000 );
			var groundMat = new THREE.MeshPhongMaterial( { color: 0xffffff, specular: 0x050505 } );
			groundMat.color.setHSL( 0.095, 1, 0.75 );
			var ground = new THREE.Mesh( groundGeo, groundMat );
			//ground.position.y = -0.5;
			ground.rotation.x = -Math.PI/2;
			scene.add( ground );
			ground.receiveShadow = true;
			
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			document.body.appendChild( stats.domElement );
			
			// uncomment if you need to draw coordinate axes when building the scene
			Coordinates.drawAllAxes();
			
			controls = new THREE.OrbitControls( camera );
			controls.addEventListener( 'change', Render );

      // From here inspired by
      // https://threejsfundamentals.org/threejs/lessons/threejs-voxel-geometry.html

      // TEXTURE LOADING
      const loader = new THREE.TextureLoader();
      const texture = loader.load('textures/flourish-cc-by-nc-sa.png', Render);
      texture.magFilter = THREE.NearestFilter;
      texture.minFilter = THREE.NearestFilter;


      //const cellSize = 32;
      const cellSize = 5;

      const tileSize = 16;
      const tileTextureWidth = 256;
      const tileTextureHeight = 64;

      world = new VoxelWorld({
        cellSize,
        tileSize,
        tileTextureWidth,
        tileTextureHeight,
      });


      // // Shadow Test
      // world.setVoxel(0, 0, 0, randInt(1,17));
      // world.setVoxel(0, 1, 1, randInt(1,17));

      // // Common Face Test
      // // (use wireframe)
      // world.setVoxel(5, 0, 0, randInt(1,17));
      // world.setVoxel(5, 0, 1, randInt(1,17)); // shadow problem?

      let cubeDim = 5;
      for (let y = 0; y < cubeDim; ++y) {
        for (let z = 0; z < cubeDim; ++z) {
          for (let x = 0; x < cubeDim; ++x) {
              world.setVoxel(x, y, z, 7);
              //world.setVoxel(x, y, z, randInt(1, 17));
              //world.setVoxel(x + cellSize + 3, y, z, randInt(1, 17));
          }
        }
      }

      world.setVoxel(2, 5, 2, 10); // TODO fix cells or use bigger cellSize

      const {positions, normals, uvs, indices} = world.generateGeometryDataForCell(0, 0, 0);
      const geometry = new THREE.BufferGeometry();

      //const material = new THREE.MeshPhongMaterial({
      const material = new THREE.MeshLambertMaterial({
        map: texture,
        side: THREE.DoubleSide,
        alphaTest: 0.1,
        transparent: true,
        //color: 'green',
        //wireframe: true,

      });

      const positionNumComponents = 3;
      const normalNumComponents = 3;
      const uvNumComponents = 2;
      geometry.setAttribute(
          'position',
          new THREE.BufferAttribute(new Float32Array(positions), positionNumComponents));
      geometry.setAttribute(
          'normal',
          new THREE.BufferAttribute(new Float32Array(normals), normalNumComponents));
      geometry.setAttribute(
          'uv',
          new THREE.BufferAttribute(new Float32Array(uvs), uvNumComponents));
      geometry.setIndex(indices);
      var mesh = new THREE.Mesh(geometry, material);

      // TODO fix shadows
			//mesh.castShadow = true;
			//mesh.receiveShadow = true;

      scene.add(mesh);
		}

    function randInt(min, max) {
      return Math.floor(Math.random() * (max - min) + min);
    }

    class VoxelWorld {

      constructor(options) {
        this.cellSize = options.cellSize;
        this.tileSize = options.tileSize;

        this.tileTextureWidth = options.tileTextureWidth;
        this.tileTextureHeight = options.tileTextureHeight;

        const {cellSize} = this; // why needed?

        this.cellSliceSize = cellSize * cellSize;
        this.cells = {};
      }

      computeCellId(x, y, z) {
        const {cellSize} = this;
        const cellX = Math.floor(x / cellSize);
        const cellY = Math.floor(y / cellSize);
        const cellZ = Math.floor(z / cellSize);
        return `${cellX},${cellY},${cellZ}`; // create string
      }

      computeVoxelOffset(x, y, z) {
        const {cellSize, cellSliceSize} = this;
        const voxelX = THREE.Math.euclideanModulo(x, cellSize) | 0;
        const voxelY = THREE.Math.euclideanModulo(y, cellSize) | 0;
        const voxelZ = THREE.Math.euclideanModulo(z, cellSize) | 0;
        return voxelY * cellSliceSize +
               voxelZ * cellSize +
               voxelX;
      }

      getCellForVoxel(x, y, z) {
        return this.cells[this.computeCellId(x, y, z)];
      }

      addCellForVoxel(x, y, z) {
        const cellId = this.computeCellId(x, y, z);
        let cell = this.cells[cellId];
        if (!cell) {
          const {cellSize} = this;
          cell = new Uint8Array(cellSize * cellSize * cellSize);
          this.cells[cellId] = cell;
        }
        return cell;
      }

      setVoxel(x, y, z, v) {
        let cell = this.getCellForVoxel(x, y, z);
        if (!cell) {
          cell = this.addCellForVoxel(x, y, z);
        }
        const voxelOffset = this.computeVoxelOffset(x, y, z);
        cell[voxelOffset] = v;
      }

      getVoxel(x, y, z) {
        const cell = this.getCellForVoxel(x, y, z);
        if (!cell) {
          return 0;
        }
        const voxelOffset = this.computeVoxelOffset(x, y, z);
        return cell[voxelOffset];
      }

      generateGeometryDataForCell(cellX, cellY, cellZ) {
         const {cellSize, tileSize, tileTextureWidth, tileTextureHeight} = this;
         const positions = [];
         const normals = [];
         const uvs = [];
         const indices = [];
         const startX = cellX * cellSize;
         const startY = cellY * cellSize;
         const startZ = cellZ * cellSize;

         for (let y = 0; y < cellSize; ++y) {
           const voxelY = startY + y;
           for (let z = 0; z < cellSize; ++z) {
             const voxelZ = startZ + z;
             for (let x = 0; x < cellSize; ++x) {
               const voxelX = startX + x;
               const voxel = this.getVoxel(voxelX, voxelY, voxelZ);
               if (voxel) {
                 // voxel 0 is sky (empty) so for UVs we start at 0
                 const uvVoxel = voxel - 1;
                 // There is a voxel here but do we need faces for it?
                 for (const {dir, corners, uvRow} of VoxelWorld.faces) {
                   const neighbor = this.getVoxel(
                       voxelX + dir[0],
                       voxelY + dir[1],
                       voxelZ + dir[2]);
                   if (!neighbor) {
                     // this voxel has no neighbor in this direction so we need a face.
                     const ndx = positions.length / 3;
                     for (const {pos, uv} of corners) {
                       positions.push(pos[0] + x, pos[1] + y, pos[2] + z);
                       normals.push(...dir);
                       uvs.push(
                             (uvVoxel +   uv[0]) * tileSize / tileTextureWidth,
                         1 - (uvRow + 1 - uv[1]) * tileSize / tileTextureHeight);
                     }
                     indices.push(
                       ndx, ndx + 1, ndx + 2,
                       ndx + 2, ndx + 1, ndx + 3,
                     );
                   }
                 }
               }
             }
           }
         }

         return {
           positions,
           normals,
           uvs,
           indices};
      }




    }


    VoxelWorld.faces = [
      { // left
        uvRow: 0,
        dir: [ -1,  0,  0, ],
        corners: [
          { pos: [ 0, 1, 0 ], uv: [ 0, 1 ], },
          { pos: [ 0, 0, 0 ], uv: [ 0, 0 ], },
          { pos: [ 0, 1, 1 ], uv: [ 1, 1 ], },
          { pos: [ 0, 0, 1 ], uv: [ 1, 0 ], },
        ],
      },
      { // right
        uvRow: 0,
        dir: [  1,  0,  0, ],
        corners: [
          { pos: [ 1, 1, 1 ], uv: [ 0, 1 ], },
          { pos: [ 1, 0, 1 ], uv: [ 0, 0 ], },
          { pos: [ 1, 1, 0 ], uv: [ 1, 1 ], },
          { pos: [ 1, 0, 0 ], uv: [ 1, 0 ], },
        ],
      },
      { // bottom
        uvRow: 1,
        dir: [  0, -1,  0, ],
        corners: [
          { pos: [ 1, 0, 1 ], uv: [ 1, 0 ], },
          { pos: [ 0, 0, 1 ], uv: [ 0, 0 ], },
          { pos: [ 1, 0, 0 ], uv: [ 1, 1 ], },
          { pos: [ 0, 0, 0 ], uv: [ 0, 1 ], },
        ],
      },
      { // top
        uvRow: 2,
        dir: [  0,  1,  0, ],
        corners: [
          { pos: [ 0, 1, 1 ], uv: [ 1, 1 ], },
          { pos: [ 1, 1, 1 ], uv: [ 0, 1 ], },
          { pos: [ 0, 1, 0 ], uv: [ 1, 0 ], },
          { pos: [ 1, 1, 0 ], uv: [ 0, 0 ], },
        ],
      },
      { // back
        uvRow: 0,
        dir: [  0,  0, -1, ],
        corners: [
          { pos: [ 1, 0, 0 ], uv: [ 0, 0 ], },
          { pos: [ 0, 0, 0 ], uv: [ 1, 0 ], },
          { pos: [ 1, 1, 0 ], uv: [ 0, 1 ], },
          { pos: [ 0, 1, 0 ], uv: [ 1, 1 ], },
        ],
      },
      { // front
        uvRow: 0,
        dir: [  0,  0,  1, ],
        corners: [
          { pos: [ 0, 0, 1 ], uv: [ 0, 0 ], },
          { pos: [ 1, 0, 1 ], uv: [ 1, 0 ], },
          { pos: [ 0, 1, 1 ], uv: [ 0, 1 ], },
          { pos: [ 1, 1, 1 ], uv: [ 1, 1 ], },
        ],
      },
    ];

		function Update() {
			requestAnimationFrame( Update );
			controls.update();  
			stats.update();
			Render();
		}
		
		function Render() {
			renderer.render(scene, camera);
		}
		
		Start();
		Update();
			
		</script>
	</body>
</html>
