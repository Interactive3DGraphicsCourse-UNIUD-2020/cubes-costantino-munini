<html>
	<head>
		<title>Experimenting with voxel</title>
		<style>
		
		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}
		
		canvas { 
			width: 100%; 
			height: 100%;
		}
	
	</style>
		<script src="lib/three.min.js"></script>
		<script src="lib/stats.min.js"></script>
		<script src="lib/Coordinates.js"></script>
		<script src="lib/OrbitControls.js"></script>
	</head>
	<body>
		
		<script>
		
		var scene, camera, renderer, controls, stats;
		
		function Start() {
			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

			renderer = new THREE.WebGLRenderer( {antialias: true} );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setClearColor( 0xf0f0f0 );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.gammaInput = true;
			renderer.gammaOutput = true;
			renderer.shadowMap.enabled = true;
			document.body.appendChild( renderer.domElement );
			
			//camera.position.set(2,2,2);
      var cpos = 200;
      var cpos = 10;
			camera.position.set(cpos, cpos, cpos);
			camera.lookAt( new THREE.Vector3(0,0,0));
			
			//var geometry = new THREE.BoxGeometry(1,1,1);
			//const loader = new THREE.TextureLoader();
			//loader.load('textures/11635.jpg', (texture => {
			//	var material = new THREE.MeshPhongMaterial( { map: texture } );
			//	var cube = new THREE.Mesh( geometry, material );
			//	cube.castShadow = true;
			//	cube.receiveShadow = true;
			//
			//	scene.add( cube );
			//}));
			//loader.load('textures/11635.jpg', (texture => {
			//	var material = new THREE.MeshPhongMaterial( { map: texture } );
			//	var cube = new THREE.Mesh( geometry, material );
			//	cube.castShadow = true;
			//	//cube.position.x = .5;
			//	cube.position.y = 1;
			//	cube.position.z = 1;
			//	cube.receiveShadow = true;
			//
			//	scene.add( cube );
			//}));
			

			hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
			hemiLight.color.setHSL( 0.6, 1, 0.6 );
			hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
			hemiLight.position.set( 0, 500, 0 );
			scene.add( hemiLight );
      
			dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
			dirLight.color.setHSL( 0.1, 1, 0.95 );
			dirLight.position.set( -1, 1.75, 1 );
			dirLight.position.multiplyScalar( 50 );
			scene.add( dirLight );
			dirLight.castShadow = true;
			dirLight.shadow.mapSize.width = 1024;
			dirLight.shadow.mapSize.height = 1024;

			// GROUND
			var groundGeo = new THREE.PlaneBufferGeometry( 10000, 10000 );
			var groundMat = new THREE.MeshPhongMaterial( { color: 0xffffff, specular: 0x050505 } );
			groundMat.color.setHSL( 0.095, 1, 0.75 );
			var ground = new THREE.Mesh( groundGeo, groundMat );
			ground.position.y = -0.5;
			ground.rotation.x = -Math.PI/2;
			scene.add( ground );
			ground.receiveShadow = true;
			
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			document.body.appendChild( stats.domElement );
			
			// uncomment if you need to draw coordinate axes when building the scene
			//Coordinates.drawAllAxes();
			
			controls = new THREE.OrbitControls( camera );
			controls.addEventListener( 'change', Render );

      // From here inspired by
      // https://threejsfundamentals.org/threejs/lessons/threejs-voxel-geometry.html

      //const cellSize = 256;
      //const cellSize = 150;
      const cellSize = 3;

      const cell = new Uint8Array(cellSize * cellSize * cellSize);

      for (let y = 0; y < cellSize; ++y) {
        for (let z = 0; z < cellSize; ++z) {
          for (let x = 0; x < cellSize; ++x) {
            const height = ( Math.sin(x / cellSize * Math.PI * 4) +
                             Math.sin(z / cellSize * Math.PI * 6) ) *
                             20 + cellSize / 2;
            //if (height > y && height < y + 1) {
            if (height < y + 1) {
              const offset = y * cellSize * cellSize +
                             z * cellSize +
                             x;
              cell[offset] = 1;
            }
          }
        }
      }

      const geometry = new THREE.BoxBufferGeometry(1, 1, 1);
      //const material = new THREE.MeshPhongMaterial({color: 'green'});
      const material = new THREE.MeshPhongMaterial({color: 'green', wireframe: true});

      for (let y = 0; y < cellSize; ++y) {
        for (let z = 0; z < cellSize; ++z) {
          for (let x = 0; x < cellSize; ++x) {
            const offset = y * cellSize * cellSize +
                           z * cellSize +
                           x;
            const block = cell[offset];
            if (block) {
              const mesh = new THREE.Mesh(geometry, material);
              mesh.position.set(x, y, z);
              scene.add(mesh);
            }
          }
        }
      }			



		}


    class VoxelWorld {
      constructor(cellSize) {
        this.cellSize = cellSize;
      }

      generateGeometryDataForCell(cellX, cellY, cellZ) {
        const {cellSize} = this; 

        const startX = cellX * cellSize;
        const startY = cellY * cellSize;
        const startZ = cellZ * cellSize;

        const positions = [];
        const normals   = [];
        const indices   = [];

        for (let y = 0; y<cellSize; ++y) {
          const voxelY = startY + y;
          for (let z = 0; z<cellSize; ++z) {
            const voxelZ = startZ + z;
            for (let x = 0; x<cellSize; ++x) {
              const voxelX = startX + x;
              const voxel = this.getVoxel(voxelX, voxelY, voxelZ);
              if (voxel) {
                for (const {dir, corners} of VoxelWorld.faces) {
                  const neighbor = this.getVoxel( voxelX + dir[0], 
                                                  voxelY + dir[1], 
                                                  voxelZ + dir[2]);
                  if (!neighbor) {
                    // face needed in this direction
                    const ndx = positions.lenght / 3;
                    for (const pos of corners) {
                      position.push(pos[0] + x, pos[1] + y, pos[2] + z);
                      normals.push(...dir);
                  }
                }
              }
            }
          }
        }
      }

    }

    VoxelWorld.faces = [
      { // left
        dir: [ -1,  0,  0, ],
      },
      { // right
        dir: [  1,  0,  0, ],
      },
      { // bottom
        dir: [  0, -1,  0, ],
      },
      { // top
        dir: [  0,  1,  0, ],
      },
      { // back
        dir: [  0,  0, -1, ],
      },
      { // front
        dir: [  0,  0,  1, ],
      },
    ];


		
		function Update() {
			requestAnimationFrame( Update );
			controls.update();  
			stats.update();
			Render();
		}
		
		function Render() {
			
			renderer.render(scene, camera);
		}
		
		Start();
		Update();
			
		</script>
	</body>
</html>
