<html>
	<head>
		<title>Voxel Boat!</title>
		<style>
		
		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}
		
		canvas { 
			width: 100%; 
			height: 100%;
		}
	
	</style>
		<script src="lib/three.min.js"></script>
		<script src="lib/stats.min.js"></script>
		<script src="lib/Coordinates.js"></script>
		<script src="lib/OrbitControls.js"></script>
	</head>
	<body>

		<script type="x-shader/x-vertex" id="vertexshader">
			attribute float displacement;
			varying vec3 vNormal;

			void main() {
				vNormal = normal;
        vec3 upVec = vec3(0,1,0);
				vec3 newPosition = position + upVec * vec3( displacement );

				gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );
			}
		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">
			varying vec3 vNormal;
			uniform vec3 color;

			void main() {
				vec3 light = vec3( 0.5, 0.2, 1.0 );
				light = normalize( light );
				float dProd = dot( vNormal, light ) * 0.5 + 0.5;

				gl_FragColor = vec4( vec3( dProd ) * vec3( color ), 1.0 );
			}
		</script>


		
		<script>
		
		var scene, camera, renderer, controls, stats;
    var world, cellSize;
    var cameraPivot;
		
		function Start() {
			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

			renderer = new THREE.WebGLRenderer( {antialias: true} );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setClearColor( 0xf0f0f0 );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.gammaInput = true;
			renderer.gammaOutput = true;
			renderer.shadowMap.enabled = true;
			document.body.appendChild( renderer.domElement );
			
			//camera.position.set(38, 20, 60);
			camera.position.set(30, 20, 30);
      camera.lookAt( new THREE.Vector3(0,0,0));

      //cameraPivot = new THREE.Object3D();
      //cameraPivot.add(camera);
      //scene.add(cameraPivot);
			
      // LIGHTS
			var hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
			hemiLight.color.setHSL( 0.6, 1, 0.6 );
			hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
			hemiLight.position.set( 0, 500, 0 );
			scene.add( hemiLight );
      
			var dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
			dirLight.color.setHSL( 0.1, 1, 0.95 );
			dirLight.position.set( -1, 1.75, 1 );
			dirLight.position.multiplyScalar( 50 );
			scene.add( dirLight );
			dirLight.castShadow = true;
			dirLight.shadow.mapSize.width = 1024;
			dirLight.shadow.mapSize.height = 1024;

			// GROUND
			var groundGeo = new THREE.PlaneBufferGeometry( 10000, 10000 );
			var groundMat = new THREE.MeshPhongMaterial( { color: 0xffffff, specular: 0x050505 } );
			groundMat.color.setHSL( 0.095, 1, 0.75 );
			var ground = new THREE.Mesh( groundGeo, groundMat );
			//ground.position.y = -0.5;
			ground.rotation.x = -Math.PI/2;
			//scene.add( ground );
			ground.receiveShadow = true;
			
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			document.body.appendChild( stats.domElement );
			
			// uncomment if you need to draw coordinate axes when building the scene
			//Coordinates.drawAllAxes();
			
      controls = new THREE.OrbitControls(camera);
      controls.addEventListener('change', Render, { capture: false, passive: false });
      controls.target = new THREE.Vector3(0, 0, 0);

      // From here inspired by
      // https://threejsfundamentals.org/threejs/lessons/threejs-voxel-geometry.html

      // TEXTURE LOADING
      const loader = new THREE.TextureLoader();
      const texture = loader.load('textures/flourish-cc-by-nc-sa.png', Render);
      texture.magFilter = THREE.NearestFilter;
      texture.minFilter = THREE.NearestFilter;


      cellSize = 64;
      //const cellSize = 5;

      const tileSize = 16;
      const tileTextureWidth = 256;
      const tileTextureHeight = 64;

      world = new VoxelWorld({
        cellSize,
        tileSize,
        tileTextureWidth,
        tileTextureHeight,
      });


      // TODO code this boat
      // https://sketchfab.com/3d-models/boat-voxel-0ecad35f37504ca3b54679494f0a23ba

      let offsetX = 15;
      let offsetY = 0;
      let offsetZ = 15;

      // BODY
      let bodyOffsetX = 15;
      let bodyOffsetY = 0;
      let bodyOffsetZ = 15;

      let boatLength = 34;
      let boatWidths = [5, 7, 9, 11];
      let boatHeight = boatWidths.length;

      for (let y = 0; y < boatHeight; ++y) {
        for (let z = 0; z < boatLength; ++z) {
          for (let x = 0; x < boatWidths[y]; ++x) {
            world.setVoxel(x + bodyOffsetX, y + offsetY, z + offsetZ, 10);
          }
        }
        bodyOffsetX -= 1;
      }

      // BOW (prua)
      let bowOffsetY = 0;
      let bowOffsetZ = offsetZ + boatLength;
      let bowOffsetX = [1, -1, -2];

      let bowLengths = 3;
      let bowWidths = [3, 7, 9, 5, 7, 5];
      let bowHeights = [3, 2, 1];

      for (let z = 0; z < bowLengths; ++z) {
        bowOffsetY += 1;
        for (let y = 0; y < bowHeights[z]; ++y) {
          for (let x = 0; x < bowWidths[y]; ++x) {
            world.setVoxel(x + offsetX + bowOffsetX[y], y + bowOffsetY, z + bowOffsetZ, 10);
          }
        }
      }

      let baseWidths = [3, 9, 7, 5, 3, 1];
      let baseOffsetX = [1, -2, -1, 0, 1, 2];

      for (let z = 0; z < 7; ++z) {
        for (let x = 0; x < baseWidths[z]; ++x) {
          world.setVoxel(x + offsetX + baseOffsetX[z], 4, z + bowOffsetZ - 2, 10);
        }
      }

      // SPUNTONE
			var cubeGeometry2 = new THREE.BoxGeometry(1,1,1)

      const spuntone_texture = loader.load('textures/wood.png', Render);
      spuntone_texture.magFilter = THREE.NearestFilter;
      spuntone_texture.minFilter = THREE.NearestFilter;

      var cubeMaterial2 = new THREE.MeshBasicMaterial( { map: spuntone_texture} );
      var cube2OffsetX = 0.5;
      var cube2OffsetY = 0.5;
      var cube2OffsetZ = 0.5;
      var spuntoneOffsetX = Math.floor(boatWidths[3] / 2) + bodyOffsetX + cube2OffsetX + 1;
      var spuntoneOffsetY = 5 + cube2OffsetY;
      var spuntoneOffsetZ = boatLength + offsetZ + cube2OffsetZ;

      var gradini = [4, 3, 3];

      var spuntone = new THREE.Object3D();

      var cube2 = new THREE.Mesh(cubeGeometry2, cubeMaterial2);
      for (let y = 0 ; y < 3; ++y) {
        for (let z = 0 ; z < gradini[y]; ++z) {
          var cube2_clone = cube2.clone();
          cube2.position.x = spuntoneOffsetX; 
          cube2.position.y = spuntoneOffsetY + y; 
          cube2.position.z = spuntoneOffsetZ + z;
          spuntone.add(cube2_clone);
        }
        spuntoneOffsetZ++;
      }

      // corni
      for (let y = 0 ; y < 3; ++y) {
        if (y < 2) {
          var cube2_clone = cube2.clone();
          cube2.position.x = spuntoneOffsetX - 1; 
          cube2.position.y = spuntoneOffsetY + y + 2; 
          cube2.position.z = spuntoneOffsetZ;
          spuntone.add(cube2_clone);
          cube2_clone = cube2.clone();
          cube2.position.x = spuntoneOffsetX + 1; 
          cube2.position.y = spuntoneOffsetY + y + 2; 
          cube2.position.z = spuntoneOffsetZ;
          spuntone.add(cube2_clone);
        } else {
          cube2_clone = cube2.clone();
          cube2.position.x = spuntoneOffsetX - 1; 
          cube2.position.y = spuntoneOffsetY + y + 1; 
          cube2.position.z = spuntoneOffsetZ + 1;
          spuntone.add(cube2_clone);
          cube2_clone = cube2.clone();
          cube2.position.x = spuntoneOffsetX + 1; 
          cube2.position.y = spuntoneOffsetY + y + 1; 
          cube2.position.z = spuntoneOffsetZ + 1;
          spuntone.add(cube2_clone);
        }
      }

      var cube2_clone = cube2.clone();
      cube2.position.x = spuntoneOffsetX; 
      cube2.position.y = spuntoneOffsetY + 2; 
      cube2.position.z = spuntoneOffsetZ + 1;
      spuntone.add(cube2_clone);

      var cube2_clone = cube2.clone();
      cube2.position.x = spuntoneOffsetX; 
      cube2.position.y = spuntoneOffsetY + 3; 
      cube2.position.z = spuntoneOffsetZ + 1;
      spuntone.add(cube2_clone);

      var cube2_clone = cube2.clone();
      cube2.position.x = spuntoneOffsetX - 1; 
      cube2.position.y = spuntoneOffsetY + 3; 
      cube2.position.z = spuntoneOffsetZ + 1;
      spuntone.add(cube2_clone); // Stranezze...

      scene.add(spuntone);


      // STERN (poppa)
      let sternOffsetY = 3;
      let sternOffsetZ = 12;
      let sternOffsetX = [1, -1, -2];

      let sternLengths = 3;
      let sternWidths = [3, 7, 9, 5, 7, 5];
      let sternHeights = [1, 2, 3];

      for (let z = 0; z < sternLengths; ++z) {
        for (let y = 0; y < sternHeights[z]; ++y) {
          for (let x = 0; x < sternWidths[y]; ++x) {
            world.setVoxel(x + offsetX + sternOffsetX[y], y + sternOffsetY, z + sternOffsetZ, 10);
            // console.log("coor: ", x + offsetX + sternOffsetX[y], y + sternOffsetY, z + sternOffsetZ);
          }
        }
        sternOffsetY -= 1;
      }

      let baseWidthsInv = [1, 3, 5, 7, 9, 3];
      let baseOffsetXInv = [2, 1, 0, -1, -2, 1];

      for (let z = 0; z < 7; ++z) {
        for (let x = 0; x < baseWidthsInv[z]; ++x) {
          world.setVoxel(x + offsetX + baseOffsetXInv[z], 4, z + sternOffsetZ - 2, 10);
        }
      }

      var spuntone_clone = spuntone.clone();
      spuntone_clone.position.x = offsetX + 20;
      spuntone_clone.position.y = 0; 
      spuntone_clone.position.z = offsetZ + 48;
      spuntone_clone.rotation.y = 180 * Math.PI / 180;
      scene.add(spuntone_clone);


      // PARAPET (parapetto)
      let parapetLength = boatLength;

      let parapetOffsetX = 12;
      let parapetOffsetY = 4;
      let parapetOffsetZ = 15;

      for (let z = 0; z < parapetLength; ++z) {
        world.setVoxel(parapetOffsetX, parapetOffsetY, z + parapetOffsetZ, 10);
        world.setVoxel(parapetOffsetX + 10, parapetOffsetY, z + parapetOffsetZ, 10);
        if (z % 3 == 0) {
          world.setVoxel(parapetOffsetX, parapetOffsetY + 1, z + parapetOffsetZ, 10);
          world.setVoxel(parapetOffsetX + 10, parapetOffsetY + 1, z + parapetOffsetZ, 10);
        }
      }


      // TREE (albero maestro)
      let treeHeight  = 26;
      let treeBaseLength = 2;
      let treeBaseWidth = 3;

      let treeOffsetX = Math.floor(boatWidths[3] / 2) + bodyOffsetX;
      let treeOffsetY = boatHeight; // + bodyOffsetU;
      let treeOffsetZ = Math.floor(boatLength / 2) + bodyOffsetZ;

      for (let y = 0; y < treeHeight; ++y) {
        for (let z = 0; z < treeBaseLength; ++z) {
          for (let x = 0; x < treeBaseWidth; ++x) {
            world.setVoxel(x + treeOffsetX,
                           y + treeOffsetY,
                           z + treeOffsetZ, 10);
          }
        }
      }

      let horizontalVSpace = [8, treeHeight - 5];
      let horizontalLen    = [15, 21];

      for (let i = 0; i < horizontalVSpace.length; i++) {
        let y = horizontalVSpace[i];
        for (let x = 0; x < horizontalLen[i]; ++x) {
              world.setVoxel(x + treeOffsetX - Math.floor(horizontalLen[i]/2) + 1,
                            y + treeOffsetY,
                            treeOffsetZ + 1, 10);
        }
      }

      // SAIL (vela)
      let sailWidth = 21;

      let sailOffsetX = treeOffsetX - Math.floor(horizontalLen[1] / 2) + 1;
      let sailOffsetY = horizontalVSpace[0] + treeOffsetY;
      let sailOffsetZ = treeOffsetZ + 2;

      let sailYs = [0,0,1,2,3,4,5,6,7,8,9,10,11,12,13];
      let sailZs = [0,1,2,3,3,4,4,4,4,3,3, 2, 1, 0, 0];

      for (let i = 0; i < sailYs.length; i++) {
        let y = sailYs[i];
        let z = sailZs[i];
          for (let x = 0; x < sailWidth; ++x) {
            world.setVoxel(x + sailOffsetX,
                           y + sailOffsetY,
                           z + sailOffsetZ, 3);
          }
      }





      // OARS (remi)
			var cubeGeometry = new THREE.BoxGeometry(1,1,1)

      const oar_texture = loader.load('textures/wood.png', Render);
      oar_texture.magFilter = THREE.NearestFilter;
      oar_texture.minFilter = THREE.NearestFilter;

      var cubeMaterial = new THREE.MeshBasicMaterial( { map: oar_texture} );
      var cubeOffsetX = 0.5;
      var cubeOffsetY = 0.5;
      var cubeOffsetZ = 0.5;

      var oar = new THREE.Object3D();
      oar.name = "oar_1";

      for (let x = 0 ; x < 3 + 2 + 3; x++){
        var cube = new THREE.Mesh( cubeGeometry, cubeMaterial );
        cube.position.x = x + cubeOffsetX; 
        cube.position.y = cubeOffsetY; 
        cube.position.z = cubeOffsetZ; 
        if (x >= 3) {
          cube.position.y--;
        }
        if (x >= 3 + 2) {
          cube.position.y--;
        }
        cube.position.z = cubeOffsetZ;
        oar.add( cube );
      }
      //scene.add(oar);

      var oarsOffsetX = 13;
      var oarsOffsetY = 2;
      var oarsOffsetZ = 15 + 8;

      for (let z = 0; z < 5; z++){
        var oar_clone = oar.clone();
        oar_clone.position.x = oarsOffsetX + boatWidths[2];
        oar_clone.position.y = oarsOffsetY;
        oar_clone.position.z = z*5 + oarsOffsetZ;
        oar_clone.name = `oar_left_${z}`;
        scene.add(oar_clone);

        oar_clone = oar.clone();
        oar_clone.position.x = oarsOffsetX;
        oar_clone.position.y = oarsOffsetY;
        oar_clone.position.z = z*5 + oarsOffsetZ;
        oar_clone.rotation.y = 180 * Math.PI/180;
        oar_clone.name = `oar_right_${z}`;
        scene.add(oar_clone);
      }













      const {positions, normals, uvs, indices} = world.generateGeometryDataForCell(0, 0, 0);
      const geometry = new THREE.BufferGeometry();

      //const material = new THREE.MeshPhongMaterial({
      const material = new THREE.MeshLambertMaterial({
        map: texture,
        side: THREE.DoubleSide,
        alphaTest: 0.1,
        transparent: true,
        //color: 'green',
        //wireframe: true,

      });

      const positionNumComponents = 3;
      const normalNumComponents = 3;
      const uvNumComponents = 2;
      geometry.setAttribute(
          'position',
          new THREE.BufferAttribute(new Float32Array(positions), positionNumComponents));
      geometry.setAttribute(
          'normal',
          new THREE.BufferAttribute(new Float32Array(normals), normalNumComponents));
      geometry.setAttribute(
          'uv',
          new THREE.BufferAttribute(new Float32Array(uvs), uvNumComponents));
      geometry.setIndex(indices);
      var mesh = new THREE.Mesh(geometry, material);

      // TODO fix shadows
			mesh.castShadow = true;
			mesh.receiveShadow = true;

      scene.add(mesh);

      addSea();

      //cameraPivot.position.x = treeOffsetX;
      //cameraPivot.position.y = treeOffsetY;
      //cameraPivot.position.z = treeOffsetZ;
		}

    function randInt(min, max) {
      return Math.floor(Math.random() * (max - min) + min);
    }


    let seaDim, seaMesh;

    function addSea() {
      var seaTextureNum = 13;
      seaDim = cellSize - 2;
      var seaOffsetX = cellSize;
      var seaOffsetZ = cellSize;

      for (let x = 0; x < seaDim; ++x) {
        for (let z = 0; z < seaDim; ++z) {
          world.setVoxel(x + seaOffsetX, 0, z + seaOffsetZ, seaTextureNum);
        }
      }

      // CREATE MESH FOR SEA
      const {positions, normals, uvs, indices} = world.generateGeometryDataForCell(1, 0, 1, full=true);
      seaGeometry = new THREE.BufferGeometry();

      seaUniforms = {
        "color": { value: new THREE.Color( 0x006994 ) }, // TODO add texture
      };

      const seaMaterial = new THREE.ShaderMaterial( {
        side: THREE.DoubleSide, // TODO
        //alphaTest: 0.1,
        //transparent: true,
        uniforms: seaUniforms,
        vertexShader: document.getElementById( 'vertexshader' ).textContent,
        fragmentShader: document.getElementById( 'fragmentshader' ).textContent
      } );

      const positionNumComponents = 3;
      const normalNumComponents = 3;
      const uvNumComponents = 2;
      seaGeometry.setAttribute(
          'position',
          new THREE.BufferAttribute(new Float32Array(positions), positionNumComponents));
      seaGeometry.setAttribute(
          'normal',
          new THREE.BufferAttribute(new Float32Array(normals), normalNumComponents));
      seaGeometry.setAttribute(
          'uv',
          new THREE.BufferAttribute(new Float32Array(uvs), uvNumComponents));
      seaGeometry.setIndex(indices);

      displacement = new Float32Array( seaGeometry.attributes.position.count );
      seaGeometry.setAttribute( 'displacement', new THREE.BufferAttribute( displacement, 1 ) );

      seaMesh = new THREE.Mesh(seaGeometry, seaMaterial);
      seaMesh.position.x = - seaDim / 4;

      scene.add(seaMesh);
    }




    class VoxelWorld {

      constructor(options) {
        this.cellSize = options.cellSize;

        this.tileSize = options.tileSize;
        this.tileTextureWidth = options.tileTextureWidth;
        this.tileTextureHeight = options.tileTextureHeight;

        const {cellSize} = this; // why needed?

        this.cellSliceSize = cellSize * cellSize;
        this.cells = {};
      }

      computeCellId(x, y, z) {
        const {cellSize} = this;
        const cellX = Math.floor(x / cellSize);
        const cellY = Math.floor(y / cellSize);
        const cellZ = Math.floor(z / cellSize);
        return `${cellX},${cellY},${cellZ}`; // create string
      }

      computeVoxelOffset(x, y, z) {
        const {cellSize, cellSliceSize} = this;
        const voxelX = THREE.Math.euclideanModulo(x, cellSize) | 0;
        const voxelY = THREE.Math.euclideanModulo(y, cellSize) | 0;
        const voxelZ = THREE.Math.euclideanModulo(z, cellSize) | 0;
        return voxelY * cellSliceSize +
               voxelZ * cellSize +
               voxelX;
      }

      getCellForVoxel(x, y, z) {
        return this.cells[this.computeCellId(x, y, z)];
      }

      addCellForVoxel(x, y, z) {
        const cellId = this.computeCellId(x, y, z);
        let cell = this.cells[cellId];
        if (!cell) {
          const {cellSize} = this;
          cell = new Uint8Array(cellSize * cellSize * cellSize);
          this.cells[cellId] = cell;
        }
        return cell;
      }

      setVoxel(x, y, z, v) {
        let cell = this.getCellForVoxel(x, y, z);
        if (!cell) {
          cell = this.addCellForVoxel(x, y, z);
        }
        const voxelOffset = this.computeVoxelOffset(x, y, z);
        cell[voxelOffset] = v;
      }

      getVoxel(x, y, z) {
        const cell = this.getCellForVoxel(x, y, z);
        if (!cell) {
          return 0;
        }
        const voxelOffset = this.computeVoxelOffset(x, y, z);
        return cell[voxelOffset];
      }

      generateGeometryDataForCell(cellX, cellY, cellZ, full = false) {
         const {cellSize, tileSize, tileTextureWidth, tileTextureHeight} = this;
         const positions = [];
         const normals = [];
         const uvs = [];
         const indices = [];
         const startX = cellX * cellSize;
         const startY = cellY * cellSize;
         const startZ = cellZ * cellSize;

         for (let y = 0; y < cellSize; ++y) {
           const voxelY = startY + y;
           for (let z = 0; z < cellSize; ++z) {
             const voxelZ = startZ + z;
             for (let x = 0; x < cellSize; ++x) {
               const voxelX = startX + x;
               const voxel = this.getVoxel(voxelX, voxelY, voxelZ);
               if (voxel) {
                 // voxel 0 is sky (empty) so for UVs we start at 0
                 const uvVoxel = voxel - 1;
                 // There is a voxel here but do we need faces for it?
                 for (const {dir, corners, uvRow} of VoxelWorld.faces) {
                   const neighbor = this.getVoxel(
                       voxelX + dir[0],
                       voxelY + dir[1],
                       voxelZ + dir[2]);
                   if (!neighbor || full) {
                     // this voxel has no neighbor in this direction so we need a face.
                     const ndx = positions.length / 3;
                     for (const {pos, uv} of corners) {
                       positions.push(pos[0] + x, pos[1] + y, pos[2] + z);
                       normals.push(...dir);
                       uvs.push(
                             (uvVoxel +   uv[0]) * tileSize / tileTextureWidth,
                         1 - (uvRow + 1 - uv[1]) * tileSize / tileTextureHeight);
                     }
                     indices.push(
                       ndx, ndx + 1, ndx + 2,
                       ndx + 2, ndx + 1, ndx + 3,
                     );
                   }
                 }
               }
             }
           }
         }

         return {
           positions,
           normals,
           uvs,
           indices};
      }




    }


    VoxelWorld.faces = [
      { // left
        uvRow: 0,
        dir: [ -1,  0,  0, ],
        corners: [
          { pos: [ 0, 1, 0 ], uv: [ 0, 1 ], },
          { pos: [ 0, 0, 0 ], uv: [ 0, 0 ], },
          { pos: [ 0, 1, 1 ], uv: [ 1, 1 ], },
          { pos: [ 0, 0, 1 ], uv: [ 1, 0 ], },
        ],
      },
      { // right
        uvRow: 0,
        dir: [  1,  0,  0, ],
        corners: [
          { pos: [ 1, 1, 1 ], uv: [ 0, 1 ], },
          { pos: [ 1, 0, 1 ], uv: [ 0, 0 ], },
          { pos: [ 1, 1, 0 ], uv: [ 1, 1 ], },
          { pos: [ 1, 0, 0 ], uv: [ 1, 0 ], },
        ],
      },
      { // bottom
        uvRow: 1,
        dir: [  0, -1,  0, ],
        corners: [
          { pos: [ 1, 0, 1 ], uv: [ 1, 0 ], },
          { pos: [ 0, 0, 1 ], uv: [ 0, 0 ], },
          { pos: [ 1, 0, 0 ], uv: [ 1, 1 ], },
          { pos: [ 0, 0, 0 ], uv: [ 0, 1 ], },
        ],
      },
      { // top
        uvRow: 2,
        dir: [  0,  1,  0, ],
        corners: [
          { pos: [ 0, 1, 1 ], uv: [ 1, 1 ], },
          { pos: [ 1, 1, 1 ], uv: [ 0, 1 ], },
          { pos: [ 0, 1, 0 ], uv: [ 1, 0 ], },
          { pos: [ 1, 1, 0 ], uv: [ 0, 0 ], },
        ],
      },
      { // back
        uvRow: 0,
        dir: [  0,  0, -1, ],
        corners: [
          { pos: [ 1, 0, 0 ], uv: [ 0, 0 ], },
          { pos: [ 0, 0, 0 ], uv: [ 1, 0 ], },
          { pos: [ 1, 1, 0 ], uv: [ 0, 1 ], },
          { pos: [ 0, 1, 0 ], uv: [ 1, 1 ], },
        ],
      },
      { // front
        uvRow: 0,
        dir: [  0,  0,  1, ],
        corners: [
          { pos: [ 0, 0, 1 ], uv: [ 0, 0 ], },
          { pos: [ 1, 0, 1 ], uv: [ 1, 0 ], },
          { pos: [ 0, 1, 1 ], uv: [ 0, 1 ], },
          { pos: [ 1, 1, 1 ], uv: [ 1, 1 ], },
        ],
      },
    ];


    function seaUpdate(time) {
      var group = 0;
      var groupNum = 4 * 6 * seaDim; // 4 vertici per faccia per 6 facce per righe del mare

      for ( let i = 1; i <= displacement.length; i ++ ) {
        displacement[ i ] = 0.3 * Math.sin( 0.5 * (group + time));

        if (i % groupNum == 0) {
          group++;
        }
      }
      seaMesh.geometry.attributes.displacement.needsUpdate = true;
    }


		function Update() {

      const time = Date.now() * 0.005;

      for (let z = 0; z < 5; z++){
        var oar = scene.getObjectByName(`oar_left_${z}`);
        oar.rotation.z = 0.25 * Math.sin(0.5 * time);
        oar.rotation.y = 0.3 * Math.cos(0.5 * time);

        oar = scene.getObjectByName(`oar_right_${z}`);
        oar.rotation.z = 0.25 * Math.sin(0.5 * time);
        oar.rotation.y = Math.PI;
        oar.rotation.y -= 0.3  * Math.cos(0.5 * time);
      }

      seaUpdate(time);

      //cameraPivot.rotation.y += 0.005;
      //camera.position.y = 20 +  10 * Math.sin( 0.05 * time );
      ////console.log( camera.position.y );


			requestAnimationFrame( Update );
			controls.update();  
			stats.update();
			Render();
		}

		
		function Render() {
			renderer.render(scene, camera);
		}
		
		Start();
		Update();
			
		</script>
	</body>
</html>
