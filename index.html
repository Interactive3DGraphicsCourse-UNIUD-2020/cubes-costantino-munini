<html>
	<head>
		<title>Voxel Boat!</title>
		<style>
		
		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}
		
		canvas { 
			width: 100%; 
			height: 100%;
		}
	
	</style>
		<script src="lib/three.min.js"></script>
		<script src="lib/stats.min.js"></script>
		<script src="lib/Coordinates.js"></script>
		<script src="lib/OrbitControls.js"></script>
	</head>
	<body>

		<script type="x-shader/x-vertex" id="vertexshader">
			attribute float displacement;
			varying vec3 vNormal;

			void main() {
				vNormal = normal;
        vec3 upVec = vec3(0,1,0);
				vec3 newPosition = position + upVec * vec3( displacement );

				gl_Position = projectionMatrix * modelViewMatrix * vec4( newPosition, 1.0 );
			}
		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">
			varying vec3 vNormal;
			uniform vec3 color;

			void main() {
				vec3 light = vec3( 0.5, 0.2, 1.0 );
				light = normalize( light );
				float dProd = dot( vNormal, light ) * 0.5 + 0.5;

				gl_FragColor = vec4( vec3( dProd ) * vec3( color ), 1.0 );
			}
		</script>


		
		<script type="module">

    import {VoxelWorld} from './voxelWorld.js';
    import {addBoat, updateBoat} from './boat.js';
		
		var scene, camera, renderer, controls, stats;
    var world, cellSize;
    var cameraPivot;
		
		function Start() {
			scene = new THREE.Scene();
			camera = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 0.1, 1000 );

			renderer = new THREE.WebGLRenderer( {antialias: true} );
			renderer.setSize( window.innerWidth, window.innerHeight );
			renderer.setClearColor( 0xf0f0f0 );
			renderer.setPixelRatio( window.devicePixelRatio );
			renderer.gammaInput = true;
			renderer.gammaOutput = true;
			renderer.shadowMap.enabled = true;
			document.body.appendChild( renderer.domElement );
			
			//camera.position.set(38, 20, 60);
			camera.position.set(30, 20, 30);
      camera.lookAt( new THREE.Vector3(0,0,0));

      //cameraPivot = new THREE.Object3D();
      //cameraPivot.add(camera);
      //scene.add(cameraPivot);
			
      // LIGHTS
			var hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
			hemiLight.color.setHSL( 0.6, 1, 0.6 );
			hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
			hemiLight.position.set( 0, 500, 0 );
			scene.add( hemiLight );
      
			var dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
			dirLight.color.setHSL( 0.1, 1, 0.95 );
			dirLight.position.set( -1, 1.75, 1 );
			dirLight.position.multiplyScalar( 50 );
			scene.add( dirLight );
			dirLight.castShadow = true;
			dirLight.shadow.mapSize.width = 1024;
			dirLight.shadow.mapSize.height = 1024;

			// GROUND
			var groundGeo = new THREE.PlaneBufferGeometry( 10000, 10000 );
			var groundMat = new THREE.MeshPhongMaterial( { color: 0xffffff, specular: 0x050505 } );
			groundMat.color.setHSL( 0.095, 1, 0.75 );
			var ground = new THREE.Mesh( groundGeo, groundMat );
			//ground.position.y = -0.5;
			ground.rotation.x = -Math.PI/2;
			//scene.add( ground );
			ground.receiveShadow = true;
			
			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			document.body.appendChild( stats.domElement );
			
			// uncomment if you need to draw coordinate axes when building the scene
			//Coordinates.drawAllAxes();
			
      controls = new THREE.OrbitControls(camera);
      controls.addEventListener('change', Render, { capture: false, passive: false });
      controls.target = new THREE.Vector3(0, 0, 0);

     
      //scene.add(boatMesh);

      addBoat(scene, Render);
      addSea();

      //cameraPivot.position.x = treeOffsetX;
      //cameraPivot.position.y = treeOffsetY;
      //cameraPivot.position.z = treeOffsetZ;
		}

    function randInt(min, max) {
      return Math.floor(Math.random() * (max - min) + min);
    }


    let seaDim, seaMesh;
    let displacement;

    function addSea() {
      cellSize = 64;

      const tileSize = 16;
      const tileTextureWidth = 256;
      const tileTextureHeight = 64;

      world = new VoxelWorld({
        cellSize,
        tileSize,
        tileTextureWidth,
        tileTextureHeight,
      });

      var seaTextureNum = 13;
      seaDim = cellSize - 2;
      var seaOffsetX = cellSize;
      var seaOffsetZ = cellSize;

      for (let x = 0; x < seaDim; ++x) {
        for (let z = 0; z < seaDim; ++z) {
          world.setVoxel(x + seaOffsetX, 0, z + seaOffsetZ, seaTextureNum);
        }
      }

      // CREATE MESH FOR SEA
      const {positions, normals, uvs, indices} = world.generateGeometryDataForCell(1, 0, 1, {full:true});
      var seaGeometry = new THREE.BufferGeometry();

     var seaUniforms = {
        "color": { value: new THREE.Color( 0x006994 ) }, // TODO add texture
      };

      const seaMaterial = new THREE.ShaderMaterial( {
        side: THREE.DoubleSide, // TODO
        //alphaTest: 0.1,
        //transparent: true,
        uniforms: seaUniforms,
        vertexShader: document.getElementById( 'vertexshader' ).textContent,
        fragmentShader: document.getElementById( 'fragmentshader' ).textContent
      } );

      const positionNumComponents = 3;
      const normalNumComponents = 3;
      const uvNumComponents = 2;
      seaGeometry.setAttribute(
          'position',
          new THREE.BufferAttribute(new Float32Array(positions), positionNumComponents));
      seaGeometry.setAttribute(
          'normal',
          new THREE.BufferAttribute(new Float32Array(normals), normalNumComponents));
      seaGeometry.setAttribute(
          'uv',
          new THREE.BufferAttribute(new Float32Array(uvs), uvNumComponents));
      seaGeometry.setIndex(indices);

      displacement = new Float32Array( seaGeometry.attributes.position.count );
      seaGeometry.setAttribute( 'displacement', new THREE.BufferAttribute( displacement, 1 ) );

      seaMesh = new THREE.Mesh(seaGeometry, seaMaterial);
      seaMesh.position.x = - seaDim / 4;

      scene.add(seaMesh);
    }


    function seaUpdate(time) {
      var group = 0;
      var groupNum = 4 * 6 * seaDim; // 4 vertici per faccia per 6 facce per righe del mare

      for ( let i = 1; i <= displacement.length; i ++ ) {
        displacement[ i ] = 0.3 * Math.sin( 0.5 * (group + time));

        if (i % groupNum == 0) {
          group++;
        }
      }
      seaMesh.geometry.attributes.displacement.needsUpdate = true;
    }


		function Update() {

      const time = Date.now() * 0.005;

      updateBoat(scene, time);
      seaUpdate(time);

      //cameraPivot.rotation.y += 0.005;
      //camera.position.y = 20 +  10 * Math.sin( 0.05 * time );
      ////console.log( camera.position.y );

			requestAnimationFrame( Update );
			controls.update();  
			stats.update();
			Render();
		}

		
		function Render() {
			renderer.render(scene, camera);
		}
		
		Start();
		Update();
			
		</script>
	</body>
</html>
